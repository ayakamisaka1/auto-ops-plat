# 一、背景与目标

## 1. 背景

在 AI 中台建设中，传统“流程 + LLM + Tool(Function Call)”模式容易退化为：

* LLM 只是一个被动的 tool caller
* 所有决策前置在流程中
* 系统可控但缺乏智能性

另一方面，完全放权给 LLM 又会带来：

* 不可预测行为
* 无限循环与成本失控
* 企业 / 金融场景不可审计

## 2. 目标

本架构的目标是：

> **在不引入自研 Runtime、不脱离 Spring AI 生态的前提下，
> 构建一个“可控、可审计、可上线”的流程驱动 Agent。**

核心关键词：

* 流程白盒
* 决策受控
* LLM 有限智能

---

# 二、核心设计原则（非常重要）

## 原则 1：流程负责边界，LLM 负责判断

* 流程：定义“能做什么、最多做几次、什么时候强制停”
* LLM：在边界内判断“是否继续、下一步选哪个动作”

> **流程不思考，LLM 不越界**

---

## 原则 2：LLM 的动作空间必须是有限集合

❌ 错误：

* 让 LLM 自由输出下一步行为

✅ 正确：

* 让 LLM 在预定义动作枚举中选择


```

---

## 原则 3：LLM 永远不能决定“权限型问题”

LLM 不能决定：

* 用哪个 API
* 用哪个数据库
* 是否越权调用工具

这些必须在 **流程 / 配置层** 完成。

---

## 原则 4：任何 LLM 决策都必须可审计

每一次“决定下一步”，都必须输出理由：

```json
{
  "action": "SEARCH",
  "reason": "当前信息不足以回答问题"
}
```

---

# 三、整体架构视图

```text
┌──────────────┐
│   Flow DSL   │  ← 白盒、可配置
└──────┬───────┘
       │
┌──────▼──────────┐
│ Flow Executor   │  ← 顺序 / Loop / If
└──────┬──────────┘
       │
┌──────▼──────────┐
│ LLM Node        │
│ - Prompt        │
│ - Action Schema │  ← 有限枚举
│ - Tool Binding  │
└──────┬──────────┘
       │ (Spring AI)
┌──────▼──────────┐
│ Tool(Function)  │  ← MCP / Function Call
└─────────────────┘
```

> **Spring AI 即 Runtime，不额外抽象“神秘层”**

---

# 四、Agent 的最小可用形态（核心）

## 1. 什么是“活过来的 Agent”？

> **当 LLM 的输出，能够决定：流程是否继续执行。**

不是自由行动，而是：

* 在有限动作集合中
* 决定“继续 or 停止”

---

## 2. 最小 Agent Loop 模型

```text
Loop (max = N)
 ├─ LLM 思考节点
 │    输出 action
 ├─ If action == SEARCH
 │    └─ 执行 Tool
 └─ If action == STOP
      └─ End
```

---

# 五、LLM 节点设计规范

## 1. LLM 节点职责（必须）

LLM 节点至少负责：

1. 判断当前信息是否足够
2. 决定是否继续下一步

不能只是：

* 返回 true / false
* 纯执行指令

---

## 2. LLM 输出 Schema（强约束）

```json
{
  "type": "object",
  "required": ["action", "reason"],
  "properties": {
    "action": {
      "type": "string",
      "enum": ["SEARCH", "STOP"]
    },
    "query": {
      "type": "string"
    },
    "reason": {
      "type": "string"
    }
  }
}
```

---

# 六、Tool 使用规范（Spring AI 现实版）

## 1. Tool 的本质

> **Tool 是被授权的能力，不是流程节点**

流程中只能做：

* 是否允许使用 tool
* 使用次数上限

不能做：

* 动态切换 tool provider

---

## 2. Tool 选择策略（现实约束）

在 Spring AI 下：

* Tool 必须在调用 LLM 前确定

因此：

* Tool 选择应前置在流程节点
* 或通过多次 LLM 调用完成

---

# 七、安全围栏设计（可上线关键）

## 1. 硬约束清单

* 最大 Loop 次数
* 动作枚举限制
* Tool 白名单
* 强制终止条件

---

## 2. 流程永远拥有最终否决权

```text
LLM: SEARCH
流程: 超过 maxLoop → STOP
```

> **LLM 建议，流程裁决**

---

# 八、什么时候“不要用 Agent”？

如果满足以下任一条件：

* 逻辑可完全用 if/else 表达
* 没有不确定性
* 不允许多步试探

👉 **不要用 LLM 节点**

---

# 九、结论（定调）

> 本架构不是“让 LLM 自由发挥”，
> 而是：
>
> **在流程围栏内，
> 让 LLM 负责“是否继续”的那一小步判断。**

这就是：

* 可控的 Agent
* 工程可落地的 Agent
* 能上线的 Agent

---

# 十、适用场景

* 信息检索 / 汇总
* 半自动运维
* 规则 + 判断混合场景
* AI 中台能力编排
