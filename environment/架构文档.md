# AI 中台架构设计文档（能力驱动版）

## 1. 总体设计

AI 中台以 **能力驱动（Capability-Driven）** 为核心设计理念。

在该体系中：

* **Agent 本身不直接持有任何能力**
* 所有能力均通过 **ai-client 组合工厂** 动态装配
* Agent 仅声明“**我需要什么能力**”，而非“**能力如何实现**”

> Agent 是能力的“使用者”，而不是能力的“拥有者”。

---

## 2. 核心概念

### 2.1 Agent

Agent 是一个纯粹的执行体，具备以下特征：

* ❌ 不关心 LLM 具体实现（OpenAI / DeepSeek / 私有化模型）
* ❌ 不关心 Tool 来源（MCP / 本地 / HTTP）
* ❌ 不关心 Memory 的存储介质
* ❌ 不关心 Prompt 的具体内容
* ✅ 只关心：**我要什么 ai-client 以及它具备哪些能力**

Agent 的所有能力均在运行期由中台统一装配。

---

## 3. 装配层设计

[//]: # (### 3.1 Agent 流程 JSON 分析池)

[//]: # ()
[//]: # (系统在 Spring Bean 初始化阶段构建 **Agent 流程 JSON 分析池**：)

[//]: # ()
[//]: # (* 池大小：默认 5 个常驻分析器)

[//]: # (* 职责：)

[//]: # ()
[//]: # (    * 解析 Agent 执行流程 JSON)

[//]: # (    * 产出 Agent 能力需求与执行顺序)
这里实在不可控  要优化为我自己的解析器
#### 输入

* Agent 执行流程 JSON

#### 输出

1. **Agent 能力拆解结果**

    * 所需 ai-client
    * 每个 ai-client 对应的能力集合
2. **AgentPipeline 执行流程**

    * 节点级顺序执行定义

---

### 3.2 ai-client 装配工厂

ai-client 装配工厂负责根据能力需求动态创建或复用 ai-client。

核心职责：

* 按能力组合构建 ai-client
* 判断同能力、同模型的 ai-client 是否已存在

#### 复用策略

* ✅ 已存在：直接复用
* ❌ 不存在：创建新实例并加入内存缓存

#### 缓存策略

* 默认缓存时间：10 分钟
* 缓存维度：能力集合 + 模型标识

---

## 4. AgentRuntime 能力模型

```
┌───────────────────────────────┐
│           AgentRuntime        │
│                               │
│  ┌──────────────┐             │
│  │ Reasoning    │  ← 思考能力 │
│  └──────────────┘             │
│  ┌──────────────┐             │
│  │ Interaction  │  ← 交互能力 │
│  └──────────────┘             │
│  ┌──────────────┐             │
│  │ Action       │  ← 行动能力 │
│  └──────────────┘             │
│  ┌──────────────┐             │
│  │ Knowledge    │  ← 知识能力 │
│  └──────────────┘             │
│  ┌──────────────┐             │
│  │ Memory       │  ← 记忆能力 │
│  └──────────────┘             │
│  ┌──────────────┐             │
│  │ Governance   │  ← 治理能力 │
│  └──────────────┘             │
│                               │
└───────────────────────────────┘
```

AgentRuntime 是 Agent 在运行期的能力载体，每一类能力均可独立装配、裁剪和替换。

---

## 5. Agent 组成模型

一个 Agent = **LLM + Tool + Memory + RAG + Role / Prompt**

### 5.1 LLM 调用能力（核心）

#### 表设计

* **llm_provider**：LLM 厂商表（基础 URL、鉴权方式）
* **llm_capability_endpoint**：模型能力接口表（CHAT / EMBEDDING / 其他能力）
* **llm_model**：模型表（如 deepseek-chat、gpt-4.1-mini）

> LLM 接入方式由「能力集合」决定，而非厂商决定。

---

### 5.2 Tool / MCP 调用能力

#### 表设计

* **mcp_service**：MCP 服务表
* **tool_definition**：Tool 工具定义表
* **mcp_connection_config**：MCP 连接配置表
* **tool_model_binding**：Tool × LLM 模型绑定表

设计原则：

* Agent 只暴露**所需 Tool**
* 不直接暴露整个 MCP 服务

---

### 5.3 对话记忆与 RAG 能力

#### 表设计

* **agent_memory_binding**：Agent × 记忆策略
* **conversation**：会话表（Agent × 用户）
* **message**：消息表（角色 / 内容 / token 数）
* **conversation_summary**：对话总结表
* **rag_source / rag_chunk / embedding / retrieval_profile**
* **agent_rag_binding**：Agent × RAG

---

### 5.4 角色 / Prompt 能力

#### 表设计

* **prompt_template**：Prompt 模板
* **role_definition**：角色定义
* **role_prompt_binding**：角色 × Prompt
* **agent_role_binding**：Agent × Role
* **agent_prompt_override**：Agent Prompt 覆盖（可选）

---

## 6. 能力工厂架构

| 工厂名称                    | 职责               | 对应能力        |
| ----------------------- | ---------------- | ----------- |
| LlmCapabilityFactory    | 构建 LLM Client    | 核心调用能力      |
| ToolCapabilityFactory   | 构建 MCP / Tool    | 行动能力 / 执行治理 |
| MemoryCapabilityFactory | 构建 Memory        | 状态治理 / 对话记忆 |
| PromptCapabilityFactory | 构建 Role / Prompt | 控制平面 / 行为决策 |

---

## 7. Agent 生命周期管理

### 7.1 创建 Agent

1. 使用 Agent 流程 JSON 分析池解析流程
2. 输出 Agent 所需能力与执行顺序
3. 通过能力工厂装配 ai-client
4. 按 AgentPipeline 执行装配流程

### 7.2 Agent 缓存

* AgentTemplate 缓存（默认 10 分钟）
* 内存监控 + UI 可视化

### 7.3 销毁与瞬时态

* 内存超限可批量清理
* 转为瞬时态释放 ai-client

---

## 8. AgentPipeline 执行流程

```
RootNode
  → AiClientApiNode
  → AiClientToolMcpNode
  → AiClientModelNode
  → AiClientRAGNode
  → AiClientMemoryNode
  → AiClientPromptRoleNode
  → Agent 执行
```

* **RootNode**：解析流程 JSON
* **ApiNode**：创建 LLM Client
* **Tool/MCP Node**：绑定工具能力
* **Model Node**：模型增强
* **RAG Node**：知识检索能力
* **Memory Node**：记忆注入
* **Prompt / Role Node**：行为约束

---

## 9. 总结

* Agent 是 **能力驱动 + 流程执行** 的产物
* Agent 只使用能力，不持有能力
* 所有能力通过工厂动态装配
* 流程 JSON 可直接驱动 Agent 构建与执行
* 缓存与内存治理防止 Agent 爆炸
* Agent 流程分析池提升性能并降低系统开销
